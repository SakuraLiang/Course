# 虚函数和多态
### 虚函数
- 在类的定义中，前面加有virtual关键字的成员函数就是虚函数
```ruby
class base
{
    virtual int get();
};
int base::get(){}
```
- virtual关键字只用在类滴你故意的函数声明中，写函数体时不用
- 构造函数和静态成员函数不能是虚函数
- 虚函数可以参与多态而普通函数不能
### 多态的表现形式
1. 通过基类指针调用基类和派生类中的同名虚函数时：若该指针指向一个基类的对象，那么调用的是基类的虚函数；如果该指针指向一个派生类的对象，那么被调用的是派生类的虚函数
2. 通过基类引用调用基类和派生类中的同名虚函数时：如果该引用的是一个基类的对象，那么被调用的是基类的虚函数；如果引用的是派生类的对象，那么调用的就是派生类的虚函数
- 作用：增加程序可扩充性
- 纯虚函数：连函数体都没有的函数
- 在构造函数和析构函数中调用虚函数不是多态，在编译时即可确定，调用的函数是自己的类或基类中定义的函数，不会等到运行时才决定
- 派生类和基类中同名虚函数同名同参数的函数，不加virtual也能自动成为虚函数
# 多态的实现原理
### 动态联编
- 通过基类指针或引用调用一个虚函数时，编译时不确定调用的是基类的还是派生类的函数，运行时才确定。
- 多态实现的关键：虚函数表(编译器自动生成) 每一个有虚函数的类(或有虚函数的类的派生类)都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。
- 多态的函数调用语句被编译成一系列根据基类指针所指向的(或基类引用所引用的)对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。
- 所以对象里面放的是哪一个类的虚函数表指针，就会到哪一个类的虚函数表中去查找虚函数的地址，最终调用的就是哪一个类的虚函数。
- 多态可以很好的提升程序的可扩充性，但也会增加程序的时间和空间。



# 虚析构函数
- 如果一个基类的指针指向了子类的一个对象，delete指针的时候会出现矛盾。
- 把基类的析构函数声明为virtual，派生类的析构函数可以不声明，通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数。
- 类如果定义了虚函数，则最好将析构函数定义为虚函数，即虚析构函数。


# 纯虚函数和抽象类
- 纯虚函数：没有函数体的虚函数
```ruby
class A
{
    private:
    int a;
    public:
    virtual void Print()=0;//标记为0，什么也不做
    void fun()
    {
        cout<<"fun"<<endl;
    }
};
```
- 抽象类：包含纯虚函数的类
- 抽象类只能作为基类来派生新类；不能创建抽象类的对象；抽象类的指针和引用指向由抽象类派生出来的类的对象
- 在抽象类中，成员函数可以调用纯虚函数；在析构函数或构造函数内部不能调用
- 如果一个类是从抽象类中派生出来的，它必须实现基类中所有的纯虚函数，才能成为非抽象类。只加一对花括号也算实现。
